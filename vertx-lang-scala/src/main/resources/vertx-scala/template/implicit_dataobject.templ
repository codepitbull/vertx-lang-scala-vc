\n
@comment{"# Generate the imports"}
@code{
  var className = helper.getSimpleName(type.name);
  var imps = generateImports(type, importedTypes, new java.util.ArrayList());
  imps.addAll(generateImportsForProperties(properties));
}
@foreach{importedType : imps}
import @{importedType}\n
@end{}

\n

@if{doc != null}
/**\n
@{renderDoc("  *", doc, renderDocLink)}
  */\n
@end{}
\n
  implicit class @{className}Pimped(val asJava: J@{className}) extends AnyVal {\n
\n
@foreach{property : properties}
	@if{property.doc != null}
	\n
	  /**\n
	@{renderDoc("    *", property.doc, renderDocLink)}
	    */\n
	@end{}
	@if{property.adder}
		@if{property.isMap}
		    def @{property.adderMethod}(key: String, value: @{toScalaMethodParam(property.type)}) = {\n
		      asJava.@{property.adderMethod}(key, @{conversionForJavaMethodParam('value', property.type)})\n
		    }\n
		@else{}
		    def @{property.adderMethod}(value: @{toScalaMethodParam(property.type)}) = {\n
			@if{property.type.kind == CLASS_DATA_OBJECT}
			      asJava.@{property.adderMethod}(@{conversionForJavaMethodParam('value', property.type)})\n
			@else{property.type.kind == CLASS_PRIMITIVE || property.type.kind == CLASS_BOXED_PRIMITIVE ||
			 property.type.kind == CLASS_STRING || property.type.kind == CLASS_JSON_OBJECT ||
			 property.type.kind == CLASS_JSON_ARRAY || property.type.kind == CLASS_ENUM || property.type.name == 'io.vertx.core.buffer.Buffer'}
			      asJava.@{property.adderMethod}(value)\n
			@else{}
			      asJava.@{property.adderMethod}(value.asInstanceOf)\n
			@end{}
		      }\n
		@end{}
	@end{}
	@if{property.isSetter}
		@if{property.isList}
		    def @{property.setterMethod}(value: List[@{toScalaMethodParam(property.type)}]) = {\n
			@if{property.type.kind == CLASS_PRIMITIVE || property.type.kind == CLASS_BOXED_PRIMITIVE}
		        asJava.@{property.setterMethod}(value.asJava)\n
			@else{(property.type.kind == CLASS_DATA_OBJECT || property.type.kind == CLASS_API) &&  property.type.name != 'io.vertx.core.buffer.Buffer'}
			      asJava.@{property.setterMethod}(value.asJava)\n
			@else{}
			      asJava.@{property.setterMethod}(value.asJava)\n
			@end{}
		      }\n
		@else{property.isSet}
		    def @{property.setterMethod}(value: Set[@{toScalaMethodParam(property.type)}]) = {\n
			@if{property.type.kind == CLASS_PRIMITIVE || property.type.kind == CLASS_BOXED_PRIMITIVE}
			      asJava.@{property.setterMethod}(value.asJava)\n
			@else{(property.type.kind == CLASS_DATA_OBJECT || property.type.kind == CLASS_API) &&  property.type.name != 'io.vertx.core.buffer.Buffer'}
			      asJava.@{property.setterMethod}(value.asJava)\n
			@else{}
			      asJava.@{property.setterMethod}(value.asJava)\n
			@end{}
		    }\n
		@else{property.isMap}
		    def @{property.setterMethod}(value: Map[String, @{toScalaMethodParam(property.type)}]) = {\n
			@if{property.type.kind == CLASS_PRIMITIVE || property.type.kind == CLASS_BOXED_PRIMITIVE}
			      asJava.@{property.setterMethod}(value.asJava)\n
			@else{property.type.kind == CLASS_DATA_OBJECT}
			      asJava.@{property.setterMethod}(value.asJava)\n
			@else{}
			      asJava.@{property.setterMethod}(value.asJava)\n
			@end{}
		    }\n
		@else{}
		    def @{property.setterMethod}(value: @{toScalaMethodParam(property.type)}) = {\n
			@if{property.type.kind == CLASS_DATA_OBJECT}
		      asJava.@{property.setterMethod}(@{conversionForJavaMethodParam('value', property.type)})\n
			@else{property.type.kind == CLASS_PRIMITIVE || property.type.kind == CLASS_BOXED_PRIMITIVE ||
						property.type.kind == CLASS_STRING || property.type.kind == CLASS_JSON_OBJECT ||
						property.type.kind == CLASS_JSON_ARRAY || property.type.kind == CLASS_ENUM ||
						property.type.name != 'io.vertx.core.buffer.Buffer'}
			      asJava.@{property.setterMethod}(value)\n
			@else{}
			      asJava.@{property.setterMethod}(value)\n
			@end{}
		    }\n
		@end{}
	@end{}
	@comment{Some necessary filtering as PropertyInfo has no information about static methods}
	@if{(property.setter || property.adder) && property.getterMethod != null}
	    def @{property.getterMethod}: @{fromPropertyInfoToScala(property)} = {\n
	      asJava.@{property.getterMethod}()@if{property.isMap||property.isSet||property.isList}.asScala@end{}\n
	    }\n
	@end{}
@end{}
  }\n
  \n
@if{!type.isAbstract()}
  type @{className} = J@{className}\n
  object @{className} {\n
    def apply(): J@{className} = new @{className}()\n
    def apply(json: JsonObject) = new J@{className}(json)\n
    def apply(other: J@{className}) = new J@{className}(other)\n
  }\n
@end{}
\n
